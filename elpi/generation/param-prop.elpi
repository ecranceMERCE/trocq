%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                            %                     Trocq                      %
%  _______                   %        Copyright (C) 2023 Inria & MERCE        %
% |__   __|                  %     (Mitsubishi Electric R&D Centre Europe)    %
%    | |_ __ ___   ___ __ _  %        Cyril Cohen <cyril.cohen@inria.fr>      %
%    | | '__/ _ \ / __/ _` | %        Enzo Crance <enzo.crance@inria.fr>      %
%    | | | | (_) | (_| (_| | %    Assia Mahboubi <assia.mahboubi@inria.fr>    %
%    |_|_|  \___/ \___\__, | %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                        | | %   This file is distributed under the terms of  %
%                        |_| %   GNU Lesser General Public License Version 3  %
%                            % (see LICENSE file for the text of the license) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred generate-fields
  i:map-class, i:term, i:param-class, o:list term.
generate-fields map0 R _ [R].
generate-fields map1 R _ [R, Map] :-
  Prop = sort prop,
  Map = {{ fun (T: lp:Prop) => T }}.
generate-fields map2a R RClass [R, Map, MapInR] :- std.do! [
  Prop = sort prop,
  Map = {{ fun (T: lp:Prop) => T }},

  Paths = {trocq.db.paths _},
  coq.env.global {trocq.db.transport} Transport,
  coq.env.global (const {trocq.db.id-param RClass}) IdParam,
  MapInR = {{
    fun (A B: lp:Prop) (e: lp:Paths lp:Prop A B) =>
      lp:Transport lp:Prop (lp:R A) A B e (lp:IdParam A)
  }}
].

pred generate-map-prop i:map-class, i:param-class.
generate-map-prop M RClass :- std.do! [
  trocq.db.rel RClass RGR _ _ _ _,
  coq.env.global RGR R,

  Prop = sort prop,
  generate-fields M R RClass Fields,

  coq.env.global {trocq.db.sym-rel} SymRel,

  generate-fields
    M {{ lp:SymRel lp:Prop lp:Prop lp:R }}
    RClass FieldsSym,

  coq.locate {calc ("Map" ^ {map-class.to_string M} ^ ".BuildHas")} BuildHasGR,
  coq.env.global BuildHasGR BuildHas,

  Decl = app [BuildHas, Prop, Prop | Fields],
  DeclSym = app [BuildHas, Prop, Prop | FieldsSym],

  % these typechecks are very important: they add L < L1 to the constraint graph
  std.assert-ok! (coq.elaborate-skeleton Decl _Ty Decl')
    "generate-map-prop: Decl cannot be elaborated",
  std.assert-ok! (coq.elaborate-skeleton DeclSym _Ty' DeclSym')
    "generate-map-prop: DeclSym cannot be elaborated",

  @univpoly! ==>
    MapProp is
      "Map" ^ {map-class.to_string M} ^ "_Prop" ^ {param-class.to_string RClass},
    coq.env.add-const MapProp Decl' _ @transparent! _,

    MapPropSym is
      "Map" ^ {map-class.to_string M} ^ "_Prop_sym" ^
      {param-class.to_string RClass},
    coq.env.add-const MapPropSym DeclSym' _ @transparent! _
].
