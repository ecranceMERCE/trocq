%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                            %                     Trocq                      %
%  _______                   %        Copyright (C) 2023 Inria & MERCE        %
% |__   __|                  %     (Mitsubishi Electric R&D Centre Europe)    %
%    | |_ __ ___   ___ __ _  %        Cyril Cohen <cyril.cohen@inria.fr>      %
%    | | '__/ _ \ / __/ _` | %        Enzo Crance <enzo.crance@inria.fr>      %
%    | | | | (_) | (_| (_| | %    Assia Mahboubi <assia.mahboubi@inria.fr>    %
%    |_|_|  \___/ \___\__, | %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                        | | %   This file is distributed under the terms of  %
%                        |_| %   GNU Lesser General Public License Version 3  %
%                            % (see LICENSE file for the text of the license) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred generate-fields
  i:map-class, i:term, i:param-class, i:univ,
  i:univ.variable, i:univ.variable, o:list term.
generate-fields map0 R _ _ _ _ [R].
generate-fields map1 R _ _ _ _ [R, Map] :-
  Prop = sort prop,
  Map = {{ fun (T: lp:Prop) => T }}.
generate-fields map2a R RClass _ L L1 [R, Map, MapInR] :-
  Prop = sort prop,
  Map = {{ fun (T: lp:Prop) => T }},

  coq.univ-instance UI [L],
  coq.univ-instance UI1 [L1],
  coq.univ-instance UI11 [L1, L1],
  Paths = {trocq.db.paths UI1},
  Transport = pglobal {trocq.db.transport} UI11,
  IdParam = pglobal (const {trocq.db.id-param RClass}) UI,
  MapInR = {{
    fun (A B: lp:Prop) (e: lp:Paths lp:Prop A B) =>
      lp:Transport lp:Prop (lp:R A) A B e (lp:IdParam A)
  }}.

pred generate-map-prop i:map-class, i:param-class.
generate-map-prop M RClass :-
  coq.univ.new U,
  coq.univ.variable U L,
  coq.univ.alg-super U U1,
  coq.univ.variable U1 L1,

  trocq.db.rel RClass RGR _ _ _ _,
  coq.univ-instance UI [L],
  R = pglobal RGR UI,

  Prop = sort prop,
  generate-fields M R RClass U L L1 Fields,

  coq.univ-instance UI1 [L1],
  SymRel = pglobal {trocq.db.sym-rel} UI1,

  generate-fields
    M {{ lp:SymRel lp:Prop lp:Prop lp:R }}
    RClass U L L1 FieldsSym,

  coq.locate {calc ("Map" ^ {map-class.to_string M} ^ ".BuildHas")} BuildHasGR,
  BuildHas = pglobal BuildHasGR UI1,

  Decl = app [BuildHas, Prop, Prop | Fields],
  DeclSym = app [BuildHas, Prop, Prop | FieldsSym],

  (@keepunivs! ==>
    std.assert-ok! (coq.elaborate-skeleton Decl _Ty Decl')
      "generate-map-prop: Decl cannot be elaborated",
    std.assert-ok! (coq.elaborate-skeleton DeclSym _Ty' DeclSym')
      "generate-map-prop: DeclSym cannot be elaborated"
  ),

  @udecl! [L, L1] ff [] tt ==>
    MapProp is
      "Map" ^ {map-class.to_string M} ^ "_Prop" ^ {param-class.to_string RClass},
    coq.env.add-const MapProp Decl' _ @transparent! Const,
    coq.elpi.accumulate _ "trocq.db" (clause _ _ (
      trocq.db.map-sort prop M RClass (const Const)
    )),

    MapPropSym is
      "Map" ^ {map-class.to_string M} ^ "_Prop_sym" ^
      {param-class.to_string RClass},
    coq.env.add-const MapPropSym DeclSym' _ @transparent! ConstSym,
    coq.elpi.accumulate _ "trocq.db" (clause _ _ (
      trocq.db.map-sym-sort prop M RClass (const ConstSym)
    )).
