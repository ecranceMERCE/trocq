%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                            %                     Trocq                      %
%  _______                   %        Copyright (C) 2023 Inria & MERCE        %
% |__   __|                  %     (Mitsubishi Electric R&D Centre Europe)    %
%    | |_ __ ___   ___ __ _  %        Cyril Cohen <cyril.cohen@inria.fr>      %
%    | | '__/ _ \ / __/ _` | %        Enzo Crance <enzo.crance@inria.fr>      %
%    | | | | (_) | (_| (_| | %    Assia Mahboubi <assia.mahboubi@inria.fr>    %
%    |_|_|  \___/ \___\__, | %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                        | | %   This file is distributed under the terms of  %
%                        |_| %   GNU Lesser General Public License Version 3  %
%                            % (see LICENSE file for the text of the license) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred generate-fields
  i:map-class, i:term, i:param-class, i:univ,
  i:univ.variable, i:univ.variable, o:list term.
generate-fields map0 R _ _ _ _ [R].
generate-fields map1 R _ U _ _ [R, Map] :-
  Type = sort (typ U),
  Map = {{ fun (T: lp:Type) => T }}.
generate-fields map2a R RClass U L L1 [R, Map, MapInR] :-
  Type = sort (typ U),
  Map = {{ fun (T: lp:Type) => T }},

  coq.univ-instance UI [L],
  coq.univ-instance UI1 [L1],
  coq.univ-instance UI11 [L1, L1],
  Paths = {trocq.db.paths UI1},
  Transport = pglobal {coq.locate "transport"} UI11,
  IdParam = pglobal (const {trocq.db.id-param RClass}) UI,
  MapInR = {{
    fun (A B: lp:Type) (e: lp:Paths lp:Type A B) =>
      lp:Transport lp:Type (lp:R A) A B e (lp:IdParam A)
  }}.

pred generate-map-type
  i:map-class, i:param-class, i:univ, i:univ.variable, i:univ.variable.
generate-map-type M RClass U L L1 :-
  trocq.db.rel RClass RGR _ _ _ _,
  coq.univ-instance UI [L],
  R = pglobal RGR UI,

  Type = sort (typ U),
  generate-fields M R RClass U L L1 Fields,

  coq.univ-instance UI1 [L1],
  SymRel = pglobal {trocq.db.sym-rel} UI1,

  generate-fields
    M {{ lp:SymRel lp:Type lp:Type lp:R }}
    RClass U L L1 FieldsSym,

  coq.locate {calc ("Map" ^ {map-class.to_string M} ^ ".BuildHas")} BuildHasGR,
  BuildHas = pglobal BuildHasGR UI1,

  Decl = app [BuildHas, Type, Type | Fields],
  DeclSym = app [BuildHas, Type, Type | FieldsSym],

  % these typechecks are very important: they add L < L1 to the constraint graph
  std.assert-ok! (coq.typecheck Decl _) "generate-map-type: Decl ill-typed",
  std.assert-ok! (coq.typecheck DeclSym _) "generate-map-type: DeclSym ill-typed",

  @udecl! [L, L1] ff [lt L L1] tt ==>
    MapType is
      "Map" ^ {map-class.to_string M} ^ "_Type" ^ {param-class.to_string RClass},
    coq.env.add-const MapType Decl _ @transparent! _,

    MapTypeSym is
      "Map" ^ {map-class.to_string M} ^ "_Type_sym" ^ {param-class.to_string RClass},
    coq.env.add-const MapTypeSym DeclSym _ @transparent! _.

pred generate-param-type
  i:param-class, i:param-class, i:univ, i:univ.variable, i:univ.variable.
generate-param-type (pc M N as Class) RClass U L L1 :-
  Type = sort (typ U),

  trocq.db.rel Class _ BuildRelGR _ _ _,
  coq.univ-instance UI1 [L1],
  BuildRel = pglobal BuildRelGR UI1,

  map-class.to_string M MStr,
  map-class.to_string N NStr,
  coq.locate
    {calc ("Map" ^ MStr ^ "_Type" ^ {param-class.to_string RClass})} MapTypeGR,
  coq.locate
    {calc ("Map" ^ NStr ^ "_Type_sym" ^ {param-class.to_string RClass})}
    MapTypeSymGR,
  coq.univ-instance UI2 [L, L1],
  MapType = pglobal MapTypeGR UI2,
  MapTypeSym = pglobal MapTypeSymGR UI2,

  trocq.db.rel RClass RGR _ _ _ _,
  coq.univ-instance UI [L],
  R = pglobal RGR UI,

  if (std.mem! [map2b, map3, map4] M) (
    UnivalentDeclM = true,
    MapTypeF = (univalence\ {{ lp:MapType lp:univalence }})
  ) (
    UnivalentDeclM = false,
    MapTypeF = (_\ MapType)
  ),

  if (std.mem! [map2b, map3, map4] N) (
    UnivalentDeclN = true,
    MapTypeSymF = (univalence\ {{ lp:MapTypeSym lp:univalence }})
  ) (
    UnivalentDeclN = false,
    MapTypeSymF = (_\ MapTypeSym)
  ),

  % in the univalent case, add the axiom in the binder
  if (UnivalentDeclM = true ; UnivalentDeclN = true) (
    Univalence = global {coq.locate "Univalence"},

    Decl = {{
      fun (H: lp:Univalence) =>
        lp:BuildRel lp:Type lp:Type
          lp:R
          lp:{{ MapTypeF {{H}} }}
          lp:{{ MapTypeSymF {{H}} }}
    }}
  ) (
    Decl = {{
      lp:BuildRel lp:Type lp:Type
        lp:R
        lp:{{ MapTypeF _ }}
        lp:{{ MapTypeSymF _ }}
    }}
  ),

  ParamType is "Param" ^ {param-class.to_string Class} ^ "_Type" ^ {param-class.to_string RClass},
  % this typecheck is very important: it adds L < L1 to the constraint graph
  std.assert-ok! (coq.typecheck Decl _) "generate-param-type: Decl is ill-typed",
  (@udecl! [L, L1] ff [lt L L1] tt =>
    coq.env.add-const ParamType Decl _ @transparent! Const),
  coq.elpi.accumulate _ "trocq.db" (clause _ _ (trocq.db.param-type Class RClass Const)).
